// Generated by CoffeeScript 1.7.1
(function() {
  var arg, args, bowerinstall, bowerupdate, cmd, exec, fin, fs, gitmeaning, gitpull, gitstatus, npmupdate, parallel, recordstderr, series, trybower, trydirectory, trygit, trygitstatus, trynpm, _i, _len, _stderr,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('colors');

  exec = require('child_process').exec;

  fs = require('fs');

  args = process.argv.slice(2);

  for (_i = 0, _len = args.length; _i < _len; _i++) {
    arg = args[_i];
    if (arg !== 'git' && arg !== 'bower' && arg !== 'npm' && arg !== 'status') {
      console.error("\n   Usage: " + 'enhance'.cyan + " [<types>]\n\n   Types:\n   \n     git       " + 'git pull'.blue + "\n     npm       " + 'npm update --production'.blue + "\n     bower     " + 'bower update'.blue + "\n     status    " + 'git status -s --porcelain'.blue + "\n   ");
      process.exit(1);
    }
  }

  _stderr = [];

  recordstderr = function(stderr) {
    return _stderr.push(stderr);
  };

  series = function(tasks, callback) {
    var next, result;
    tasks = tasks.slice(0);
    next = function(cb) {
      var task;
      if (tasks.length === 0) {
        return cb();
      }
      task = tasks.shift();
      return task(function() {
        return next(cb);
      });
    };
    result = function(cb) {
      return next(cb);
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  parallel = function(tasks, callback) {
    var count, result;
    count = tasks.length;
    result = function(cb) {
      var task, _j, _len1, _results;
      if (count === 0) {
        return cb();
      }
      _results = [];
      for (_j = 0, _len1 = tasks.length; _j < _len1; _j++) {
        task = tasks[_j];
        _results.push(task(function() {
          count--;
          if (count === 0) {
            return cb();
          }
        }));
      }
      return _results;
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  cmd = function(cmd, cb) {
    return exec(cmd, function(err, stdout, stderr) {
      if (err != null) {
        console.error("Issue running " + cmd);
        throw err;
      }
      if ((stderr != null) && stderr !== '') {
        recordstderr(stderr);
      }
      return cb(stdout);
    });
  };

  gitpull = function(dir, cb) {
    return cmd("cd " + dir + " && git pull", cb);
  };

  trygit = function(dir, cb) {
    return fs.exists("" + dir + "/.git", function(isthere) {
      if (!isthere) {
        return cb();
      }
      return series([
        function(cb) {
          return gitpull(dir, cb);
        }
      ], function() {
        console.log("   " + 'git\'d'.blue + "      " + dir);
        return cb();
      });
    });
  };

  gitmeaning = {
    ' M': 'modified',
    ' A': 'added',
    ' D': 'deleted',
    ' R': 'renamed',
    ' C': 'copied',
    '??': 'untracked',
    '!!': 'ignored'
  };

  gitstatus = function(dir, cb) {
    return cmd("cd " + dir + " && git status -s --porcelain", cb);
  };

  trygitstatus = function(dir, cb) {
    return fs.exists("" + dir + "/.git", function(isthere) {
      if (!isthere) {
        return cb();
      }
      return series([
        function(cb) {
          return gitstatus(dir, function(status) {
            var code, count, groups, line, result, type, _j, _len1, _ref;
            console.log("   " + dir.blue);
            if ((status == null) || status === '') {
              return cb();
            }
            groups = {};
            _ref = status.split('\n');
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              line = _ref[_j];
              code = line.substr(0, 2);
              if (code === '') {
                continue;
              }
              if (groups[code] == null) {
                groups[code] = 0;
              }
              groups[code]++;
            }
            result = (function() {
              var _results;
              _results = [];
              for (type in groups) {
                count = groups[type];
                if (gitmeaning[type] != null) {
                  _results.push("" + count + " " + gitmeaning[type]);
                } else {
                  _results.push("" + type + ":" + count);
                }
              }
              return _results;
            })();
            console.log("   " + (result.join(' ')));
            return cb();
          });
        }
      ], function() {
        return cb();
      });
    });
  };

  npmupdate = function(dir, cb) {
    return cmd("cd " + dir + " && npm update --production", function() {
      console.log("   " + 'npm\'d'.magenta + "      " + dir);
      return cb();
    });
  };

  trynpm = function(dir, cb) {
    return fs.exists("" + dir + "/package.json", function(isthere) {
      if (!isthere) {
        return cb();
      }
      return npmupdate(dir, cb);
    });
  };

  bowerinstall = function(dir, cb) {
    return cmd("cd " + dir + " && bower install", cb);
  };

  bowerupdate = function(dir, cb) {
    return cmd("cd " + dir + " && bower update", function() {
      console.log("   " + 'bower\'d'.green + "    " + dir);
      return cb();
    });
  };

  trybower = function(dir, cb) {
    return fs.exists("" + dir + "/bower.json", function(isthere) {
      if (!isthere) {
        return cb();
      }
      return series([
        function(cb) {
          return bowerinstall(dir, cb);
        }, function(cb) {
          return bowerupdate(dir, cb);
        }
      ], cb);
    });
  };

  trydirectory = function(dir, cb) {
    var next, tasks;
    tasks = [];
    if (args.length === 0 || __indexOf.call(args, 'git') >= 0) {
      tasks.push(function(cb) {
        return trygit(dir, cb);
      });
    }
    if (__indexOf.call(args, 'status') >= 0) {
      tasks.push(function(cb) {
        return trygitstatus(dir, cb);
      });
    }
    next = [];
    if (args.length === 0 || __indexOf.call(args, 'npm') >= 0) {
      next.push(function(cb) {
        return trynpm(dir, cb);
      });
      next.push(function(cb) {
        return trynpm("" + dir + "/web", cb);
      });
    }
    if (args.length === 0 || __indexOf.call(args, 'bower') >= 0) {
      next.push(function(cb) {
        return trybower(dir, cb);
      });
      next.push(function(cb) {
        return trybower("" + dir + "/web", cb);
      });
    }
    tasks.push(function(cb) {
      return parallel(next, cb);
    });
    return series(tasks, cb);
  };

  fin = function() {
    console.log();
    if (_stderr.length !== 0) {
      console.log('   fin with warnings.'.red);
    } else {
      console.log('   fin.'.cyan);
    }
    return console.log();
  };

  console.log();

  if (__indexOf.call(args, 'status') >= 0 && args.length !== 1) {
    console.error("\n   Usage: " + 'enhance'.cyan + " [<types>]\n\n   Types:\n   \n     git       " + 'git pull'.blue + "\n     npm       " + 'npm update --production'.blue + "\n     bower     " + 'bower update'.blue + "\n     status    " + 'git status -s --porcelain'.blue + "\n   ");
    process.exit(1);
  }

  trydirectory('.', function() {
    return fs.readdir('.', function(err, files) {
      var file, tasks, _fn, _j, _len1;
      if (err != null) {
        throw err;
      }
      tasks = [];
      _fn = function(file) {
        return tasks.push(function(cb) {
          return fs.stat(file, function(err, stat) {
            if (err != null) {
              throw err;
            }
            if (!stat.isDirectory()) {
              return cb();
            }
            return trydirectory(file, cb);
          });
        });
      };
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        file = files[_j];
        _fn(file);
      }
      return parallel(tasks, fin);
    });
  });

}).call(this);
