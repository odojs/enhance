// Generated by CoffeeScript 1.8.0
var arg, args, bowerinstall, bowerupdate, cmd, exec, fin, fs, gitfetch, gitmeaning, gitpull, gitpush, gitstatus, gittopull, gittopush, npmupdate, nukebower, nukenpm, odo, parallel, recordstderr, series, trybower, trydirectory, trygit, trygitstatus, trynpm, trynukebower, trynukenpm, tryodo, usage, _i, _len, _stderr,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

require('colors');

exec = require('child_process').exec;

fs = require('fs');

args = process.argv.slice(2);

usage = "\n   Usage: " + 'enhance'.cyan + " [<commands>]\n   \n   Default command: (this will run if no commands are specified)\n\n      status    " + 'git fetch'.blue + "\n                " + 'git status -s --porcelain'.blue + "\n                " + 'git diff --stat origin/master HEAD'.blue + "\n                " + 'git diff --stat ...origin'.blue + "\n \n   Additional commands:\n\n      push      " + 'git push'.blue + "\n      pull      " + 'git pull'.blue + "\n      npm       " + 'npm update --production'.blue + "\n      nukenpm   " + 'rm -rf node_modules'.blue + "\n      odo       " + 'npm install odo@latest --save --force' + "\n      bower     " + 'bower update'.blue + "\n      nukebower " + 'rm -rf bower_components'.blue + "\n";

process.stdout.setMaxListeners(30);

process.stderr.setMaxListeners(30);

for (_i = 0, _len = args.length; _i < _len; _i++) {
  arg = args[_i];
  if (arg !== 'pull' && arg !== 'push' && arg !== 'bower' && arg !== 'npm' && arg !== 'status' && arg !== 'nukenpm' && arg !== 'nukebower' && arg !== 'odo') {
    console.error(usage);
    process.exit(1);
  }
}

if (__indexOf.call(args, 'status') >= 0 && args.length !== 1) {
  console.error(usage);
  process.exit(1);
}

_stderr = [];

recordstderr = function(stderr) {
  return _stderr.push(stderr);
};

series = function(tasks, callback) {
  var next, result;
  tasks = tasks.slice(0);
  next = function(cb) {
    var task;
    if (tasks.length === 0) {
      return cb();
    }
    task = tasks.shift();
    return task(function() {
      return next(cb);
    });
  };
  result = function(cb) {
    return next(cb);
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _j, _len1, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_j = 0, _len1 = tasks.length; _j < _len1; _j++) {
      task = tasks[_j];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

cmd = function(cmd, cb) {
  return exec(cmd, function(err, stdout, stderr) {
    if (err != null) {
      console.error("Issue running " + cmd);
      throw err;
    }
    if ((stderr != null) && stderr !== '') {
      recordstderr(stderr);
    }
    return cb(stdout);
  });
};

gitpull = function(dir, cb) {
  return exec("cd " + dir + " && git pull", function(err, stdout, stderr) {
    if (err != null) {
      console.log("   Can't " + 'pull'.blue + " " + dir);
    } else {
      console.log("   " + 'pull\'d'.blue + "     " + dir);
    }
    return cb();
  });
};

gitpush = function(dir, cb) {
  return exec("cd " + dir + " && git push", function(err, stdout, stderr) {
    if (err != null) {
      console.log("   Can't " + 'push'.blue + " " + dir);
    } else {
      console.log("   " + 'push\'d'.blue + "     " + dir);
    }
    return cb();
  });
};

trygit = function(dir, cb) {
  return fs.exists("" + dir + "/.git", function(isthere) {
    var tasks;
    if (!isthere) {
      return cb();
    }
    tasks = [];
    if (args.length === 0 || __indexOf.call(args, 'pull') >= 0) {
      tasks.push(function(cb) {
        return gitpull(dir, cb);
      });
    }
    if (__indexOf.call(args, 'push') >= 0) {
      tasks.push(function(cb) {
        return gitpush(dir, cb);
      });
    }
    return series(tasks, cb);
  });
};

gitmeaning = {
  ' M': 'modified',
  ' A': 'added',
  ' D': 'deleted',
  ' R': 'renamed',
  ' C': 'copied',
  '??': 'untracked',
  '!!': 'ignored'
};

gitstatus = function(dir, cb) {
  return cmd("cd " + dir + " && git status -s --porcelain", cb);
};

gitfetch = function(dir, cb) {
  return cmd("cd " + dir + " && git fetch", cb);
};

gittopush = function(dir, cb) {
  return cmd("cd " + dir + " && git symbolic-ref --short -q HEAD", function(branch) {
    return cmd("cd " + dir + " && git diff --stat origin/" + (branch.trim()) + " HEAD", cb);
  });
};

gittopull = function(dir, cb) {
  return cmd("cd " + dir + " && git diff --stat ...origin", cb);
};

trygitstatus = function(dir, cb) {
  return fs.exists("" + dir + "/.git", function(isthere) {
    var results, toPull;
    if (!isthere) {
      return cb();
    }
    results = [];
    toPull = false;
    return series([
      function(cb) {
        return gitfetch(dir, cb);
      }, function(cb) {
        return gitstatus(dir, function(status) {
          var code, count, groups, line, lines, result, type, _j, _len1;
          if ((status == null) || status === '') {
            return cb();
          }
          lines = status.split('\n');
          groups = {};
          for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
            line = lines[_j];
            code = line.substr(0, 2);
            if (code === '') {
              continue;
            }
            if (groups[code] == null) {
              groups[code] = 0;
            }
            groups[code]++;
          }
          result = (function() {
            var _results;
            _results = [];
            for (type in groups) {
              count = groups[type];
              if (gitmeaning[type] != null) {
                _results.push("" + count + " " + gitmeaning[type]);
              } else {
                _results.push("" + type + ":" + count);
              }
            }
            return _results;
          })();
          results.push("   " + 'local:'.magenta + "    " + lines.length + " files changed, " + (result.join(' ')));
          return cb();
        });
      }, function(cb) {
        return gittopush(dir, function(status) {
          if ((status == null) || status === '') {
            return cb();
          }
          status = status.split('\n');
          status.pop();
          status = status.pop();
          results.push("   " + 'to push:'.magenta + "  " + (status.trim()));
          return cb();
        });
      }, function(cb) {
        return gittopull(dir, function(status) {
          if ((status == null) || status === '') {
            return cb();
          }
          status = status.split('\n');
          status.pop();
          status = status.pop();
          results.push("   " + 'to pull:'.magenta + "  " + status);
          toPull = true;
          return cb();
        });
      }
    ], function() {
      if (results.length === 0) {
        console.log(" " + 'âˆš'.green + " " + dir.blue);
      } else {
        if (toPull != null) {
          console.log(" " + 'X'.red + " " + dir.red + " is not up to date");
        } else {
          console.log(" " + 'X'.yellow + " " + dir.yellow + " has changes");
        }
        console.log(results.join('\n'));
      }
      return cb();
    });
  });
};

odo = function(dir, cb) {
  return cmd("cd " + dir + " && npm install odo@latest --save --force", function() {
    console.log("   " + 'odo\'d'.magenta + "      " + dir);
    return cb();
  });
};

tryodo = function(dir, cb) {
  return fs.exists("" + dir + "/node_modules/odo", function(isthere) {
    if (!isthere) {
      return cb();
    }
    return odo(dir, cb);
  });
};

npmupdate = function(dir, cb) {
  return cmd("cd " + dir + " && npm update --production", function() {
    console.log("   " + 'npm\'d'.magenta + "      " + dir);
    return cb();
  });
};

trynpm = function(dir, cb) {
  return fs.exists("" + dir + "/package.json", function(isthere) {
    if (!isthere) {
      return cb();
    }
    return npmupdate(dir, cb);
  });
};

nukenpm = function(dir, cb) {
  return cmd("cd " + dir + " && rm -rf node_modules", function() {
    console.log("   " + 'npm nuke\'d'.magenta + " " + dir);
    return cb();
  });
};

trynukenpm = function(dir, cb) {
  return fs.exists("" + dir + "/node_modules", function(isthere) {
    if (!isthere) {
      return cb();
    }
    return nukenpm(dir, cb);
  });
};

nukebower = function(dir, cb) {
  return cmd("cd " + dir + " && rm -rf bower_components", function() {
    console.log("   " + 'bower nuke\'d'.magenta + " " + dir);
    return cb();
  });
};

trynukebower = function(dir, cb) {
  return fs.exists("" + dir + "/bower_components", function(isthere) {
    if (!isthere) {
      return cb();
    }
    return nukebower(dir, cb);
  });
};

bowerinstall = function(dir, cb) {
  return cmd("cd " + dir + " && bower install", cb);
};

bowerupdate = function(dir, cb) {
  return cmd("cd " + dir + " && bower update", function() {
    console.log("   " + 'bower\'d'.green + "    " + dir);
    return cb();
  });
};

trybower = function(dir, cb) {
  return fs.exists("" + dir + "/bower.json", function(isthere) {
    if (!isthere) {
      return cb();
    }
    return series([
      function(cb) {
        return bowerinstall(dir, cb);
      }, function(cb) {
        return bowerupdate(dir, cb);
      }
    ], cb);
  });
};

trydirectory = function(dir, cb) {
  var next, tasks;
  tasks = [];
  if (__indexOf.call(args, 'push') >= 0 || __indexOf.call(args, 'pull') >= 0) {
    tasks.push(function(cb) {
      return trygit(dir, cb);
    });
  }
  if (args.length === 0 || __indexOf.call(args, 'status') >= 0) {
    tasks.push(function(cb) {
      return trygitstatus(dir, cb);
    });
  }
  if (__indexOf.call(args, 'nukenpm') >= 0) {
    tasks.push(function(cb) {
      return trynukenpm(dir, cb);
    });
  }
  if (__indexOf.call(args, 'nukebower') >= 0) {
    tasks.push(function(cb) {
      return trynukebower(dir, cb);
    });
  }
  next = [];
  if (__indexOf.call(args, 'npm') >= 0) {
    next.push(function(cb) {
      return trynpm(dir, cb);
    });
    next.push(function(cb) {
      return trynpm("" + dir + "/web", cb);
    });
  }
  if (__indexOf.call(args, 'odo') >= 0) {
    next.push(function(cb) {
      return tryodo(dir, cb);
    });
    next.push(function(cb) {
      return tryodo("" + dir + "/web", cb);
    });
  }
  if (__indexOf.call(args, 'bower') >= 0) {
    next.push(function(cb) {
      return trybower(dir, cb);
    });
    next.push(function(cb) {
      return trybower("" + dir + "/web", cb);
    });
  }
  tasks.push(function(cb) {
    return parallel(next, cb);
  });
  return series(tasks, cb);
};

fin = function() {
  console.log();
  if (_stderr.length !== 0) {
    console.log('   fin with warnings.'.red);
  } else {
    console.log('   fin.'.cyan);
  }
  return console.log();
};

console.log();

trydirectory('.', function() {
  return fs.readdir('.', function(err, files) {
    var file, tasks, _fn, _j, _len1;
    if (err != null) {
      throw err;
    }
    tasks = [];
    _fn = function(file) {
      return tasks.push(function(cb) {
        return fs.stat(file, function(err, stat) {
          if (err != null) {
            throw err;
          }
          if (!stat.isDirectory()) {
            return cb();
          }
          return trydirectory(file, cb);
        });
      });
    };
    for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
      file = files[_j];
      _fn(file);
    }
    return parallel(tasks, fin);
  });
});
